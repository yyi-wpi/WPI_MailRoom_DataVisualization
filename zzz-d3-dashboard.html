<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ Ultimate Package Analytics Dashboard</title>
    
    <!-- Include D3.js and TopoJSON -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <script src="https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
    
    <!-- Include Bootstrap for styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <style>
        body {
            background-color: #111;
            color: #fff;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }
        
        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .app-header {
            margin-bottom: 20px;
        }
        
        .dashboard-stats {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .card {
            background-color: #222;
            border: 1px solid #444;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .card-title {
            color: #FFD700;
            text-align: center;
            padding: 10px 0;
        }
        
        .tab-content {
            padding: 20px;
        }
        
        .nav-tabs {
            border-bottom-color: #444;
        }
        
        .nav-tabs .nav-link {
            color: #fff;
            background-color: #333;
            border-color: #444;
            margin-right: 5px;
        }
        
        .nav-tabs .nav-link.active {
            color: #FFD700;
            background-color: #222;
            border-color: #444;
        }
        
        /* County map styling */
        .county {
            stroke: #bbb;
            stroke-width: 0.3px;
        }
        
        .state {
            stroke: #555;
            stroke-width: 1px;
        }
        
        .tooltip {
            position: absolute;
            background-color: rgba(34, 34, 34, 0.9);
            border: 1px solid #FFD700;
            padding: 10px;
            pointer-events: none;
            font-family: sans-serif;
            color: #fff;
            border-radius: 5px;
            z-index: 1000;
        }
        
        /* Legend styling */
        .legend-container {
            margin-top: 20px;
            text-align: center;
        }
        
        /* Bar chart styling */
        .bar {
            cursor: pointer;
        }
        
        .bar-tooltip {
            position: absolute;
            background-color: rgba(34, 34, 34, 0.9);
            border: 1px solid #FFD700;
            padding: 5px;
            pointer-events: none;
            font-family: sans-serif;
            color: #fff;
            border-radius: 3px;
            z-index: 1000;
        }
        
        .subtitle {
            font-size: 16px;
            color: #aaa;
            margin-bottom: 20px;
            text-align: center;
        }
        
        /* For mobile responsiveness */
        @media (max-width: 768px) {
            .app-container {
                padding: 10px;
            }
            svg {
                width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container-fluid app-container">
        <div class="app-header">
            <h1 class="text-center" style="color: #FFD700; padding: 20px;">üì¶ Ultimate Package Tracking Dashboard üöÄ</h1>
            <hr>
        </div>
        
        <div class="row dashboard-stats">
            <div class="col-md-4">
                <h4 id="total-packages" style="color: #FF4500; font-size: 24px;">üì¶ Total Packages: Loading...</h4>
            </div>
            <div class="col-md-4">
                <h4 id="top-carrier" style="color: #32CD32; font-size: 24px;">üöö Top Carrier: Loading...</h4>
            </div>
            <div class="col-md-4">
                <h4 id="avg-processing" style="color: #1E90FF; font-size: 24px;">‚è≥ Avg. Processing Time: Loading...</h4>
            </div>
        </div>
        
        <ul class="nav nav-tabs" id="dashboardTabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="package-flow-tab" data-bs-toggle="tab" data-bs-target="#package-flow" type="button" role="tab" aria-controls="package-flow" aria-selected="true">üì¶ Package Flow</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="county-map-tab" data-bs-toggle="tab" data-bs-target="#county-map" type="button" role="tab" aria-controls="county-map" aria-selected="false">üåç County Map</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="stats-tab" data-bs-toggle="tab" data-bs-target="#stats" type="button" role="tab" aria-controls="stats" aria-selected="false">üìà Statistical Insights</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="insights-tab" data-bs-toggle="tab" data-bs-target="#insights" type="button" role="tab" aria-controls="insights" aria-selected="false">üìä Additional Insights</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="heatmap-tab" data-bs-toggle="tab" data-bs-target="#heatmap" type="button" role="tab" aria-controls="heatmap" aria-selected="false">üî• Heatmap & Trends</button>
            </li>
        </ul>
        
        <div class="tab-content" id="dashboardTabsContent">
            <!-- Package Flow Tab (Sankey) -->
            <div class="tab-pane fade show active" id="package-flow" role="tabpanel" aria-labelledby="package-flow-tab">
                <div class="card shadow-lg">
                    <div class="card-body">
                        <h3 class="card-title">üìä Real-time Package Flow</h3>
                        <div id="sankey-container" class="d-flex justify-content-center"></div>
                    </div>
                </div>
            </div>
            
            <!-- County Map Tab -->
            <div class="tab-pane fade" id="county-map" role="tabpanel" aria-labelledby="county-map-tab">
                <div class="card shadow-lg">
                    <div class="card-body">
                        <h3 class="card-title">üåç County Map</h3>
                        <div class="subtitle">Click on a carrier to filter the map</div>
                        <div class="carrier-chart mb-4 d-flex justify-content-center">
                            <svg id="barChart" width="800" height="200"></svg>
                        </div>
                        <div class="d-flex justify-content-center">
                            <svg id="map" width="960" height="600">
                                <g id="gMap"></g>
                            </svg>
                        </div>
                        <div class="legend-container">
                            <svg id="legend" width="500" height="60"></svg>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Statistical Insights Tab -->
            <div class="tab-pane fade" id="stats" role="tabpanel" aria-labelledby="stats-tab">
                <div class="row">
                    <div class="col-md-6">
                        <div class="card shadow-lg">
                            <div class="card-body">
                                <h3 class="card-title">üìä Carrier Distribution</h3>
                                <div id="carrier-bar-container" class="d-flex justify-content-center"></div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card shadow-lg">
                            <div class="card-body">
                                <h3 class="card-title">üì¶ Package Processing Histogram</h3>
                                <div id="histogram-container" class="d-flex justify-content-center"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Additional Insights Tab -->
            <div class="tab-pane fade" id="insights" role="tabpanel" aria-labelledby="insights-tab">
                <div class="row">
                    <div class="col-md-6">
                        <div class="card shadow-lg">
                            <div class="card-body">
                                <h3 class="card-title">üìä Processing Time Over Time</h3>
                                <div id="line-chart-container" class="d-flex justify-content-center"></div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="card shadow-lg">
                            <div class="card-body">
                                <h3 class="card-title">üì¶ Package Volume by Carrier</h3>
                                <div id="pie-chart-container" class="d-flex justify-content-center"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Heatmap & Trends Tab -->
            <div class="tab-pane fade" id="heatmap" role="tabpanel" aria-labelledby="heatmap-tab">
                <div class="card shadow-lg">
                    <div class="card-body">
                        <h3 class="card-title">‚è∞ Package Pickup Heatmap</h3>
                        <div id="pickup-heatmap-container" class="d-flex justify-content-center"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Create tooltip divs
        const tooltip = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);
            
        const barTooltip = d3.select("body").append("div")
            .attr("class", "bar-tooltip")
            .style("opacity", 0);
        
        // Define carrier colors
        const carrierColors = {
            "UPS": "#8B4513",      // Brown for UPS
            "USPS": "#1E90FF",     // Blue for USPS
            "FedEx": "#800080",    // Purple for FedEx
            "Amazon": "#FF8C00",   // Orange for Amazon
            "DHL": "#FFD700",      // Gold/Yellow for DHL
            "Other": "#2E8B57"     // Sea Green for any other carrier
        };
        
        // Load and process data
        d3.csv("Cleaned_Package_Data_County_FIPS.csv").then(function(data) {
            // Filter out rows with empty County FIPS
            const filteredData = data.filter(d => d["County FIPS"] && d["County FIPS"].trim() !== "");
            
            // Parse date fields
            filteredData.forEach(d => {
                // Convert date strings to Date objects
                const parseDate = (dateStr) => {
                    if (!dateStr) return null;
                    // Try to parse the date in MM/DD/YYYY HH:MM format
                    const parts = dateStr.split(' ');
                    if (parts.length !== 2) return null;
                    
                    const dateParts = parts[0].split('/');
                    if (dateParts.length !== 3) return null;
                    
                    const timeParts = parts[1].split(':');
                    if (timeParts.length !== 2) return null;
                    
                    return new Date(dateParts[2], dateParts[0] - 1, dateParts[1], timeParts[0], timeParts[1]);
                };
                
                d["Routed Date Time"] = parseDate(d["Routed Date Time"]);
                d["Stored Date Time"] = parseDate(d["Stored Date Time"]);
                d["Delivered Date Time"] = parseDate(d["Delivered Date Time"]);
                
                // Calculate processing times
                if (d["Routed Date Time"] && d["Stored Date Time"]) {
                    d["Routed ‚Üí Stored"] = (d["Stored Date Time"] - d["Routed Date Time"]) / (1000 * 60 * 60); // Convert to hours
                }
                
                if (d["Stored Date Time"] && d["Delivered Date Time"]) {
                    d["Stored ‚Üí Delivered"] = (d["Delivered Date Time"] - d["Stored Date Time"]) / (1000 * 60 * 60); // Convert to hours
                }
                
                if (d["Routed Date Time"] && d["Delivered Date Time"]) {
                    d["Total Processing Time"] = (d["Delivered Date Time"] - d["Routed Date Time"]) / (1000 * 60 * 60); // Convert to hours
                }
            });
            
            // Update dashboard stats
            updateDashboardStats(filteredData);
            
            // Create visualizations
            createSankeyDiagram(filteredData);
            initializeCountyMap(filteredData);
            createCarrierBar(filteredData);
            createProcessingHistogram(filteredData);
            createTimeLineChart(filteredData);
            createCarrierPieChart(filteredData);
            createPickupHeatmap(filteredData);
        });
        
        // Update dashboard stats
        function updateDashboardStats(data) {
            // Total packages
            d3.select("#total-packages").text(`üì¶ Total Packages: ${data.length.toLocaleString()}`);
            
            // Top carrier
            const carrierCounts = d3.rollup(data, v => v.length, d => d.Carrier || "Unknown");
            const topCarrier = Array.from(carrierCounts, ([key, value]) => ({ carrier: key, count: value }))
                .sort((a, b) => b.count - a.count)[0].carrier;
            d3.select("#top-carrier").text(`üöö Top Carrier: ${topCarrier}`);
            
            // Average processing time
            const validProcessingTimes = data.filter(d => d["Total Processing Time"] !== undefined && !isNaN(d["Total Processing Time"]));
            const avgProcessingTime = d3.mean(validProcessingTimes, d => d["Total Processing Time"]);
            d3.select("#avg-processing").text(`‚è≥ Avg. Processing Time: ${avgProcessingTime ? avgProcessingTime.toFixed(2) : 'N/A'} Hours`);
        }
        
        // Create Sankey diagram
        function createSankeyDiagram(data) {
            // Calculate average transit times
            const validRoutedToStored = data.filter(d => d["Routed ‚Üí Stored"] !== undefined && !isNaN(d["Routed ‚Üí Stored"]));
            const validStoredToDelivered = data.filter(d => d["Stored ‚Üí Delivered"] !== undefined && !isNaN(d["Stored ‚Üí Delivered"]));
            
            const avgRoutedToStored = d3.mean(validRoutedToStored, d => d["Routed ‚Üí Stored"]) || 12;
            const avgStoredToDelivered = d3.mean(validStoredToDelivered, d => d["Stored ‚Üí Delivered"]) || 24;
            
            // Total values for proportions
            const total = data.length;
            
            // Set up dimensions
            const sankeyWidth = 800;
            const sankeyHeight = 500;
            
            // Define Sankey diagram data
            const sankeyData = {
                nodes: [
                    { name: "üì¶ Arrived" },
                    { name: "üìç Sorting" },
                    { name: "üì¶ Storage" },
                    { name: "üöÄ Out for Delivery" },
                    { name: "üè° Delivered" }
                ],
                links: [
                    { source: 0, target: 1, value: total },
                    { source: 1, target: 2, value: total * 0.8 },
                    { source: 1, target: 3, value: total * 0.2 },
                    { source: 2, target: 3, value: total * 0.7 },
                    { source: 3, target: 4, value: total }
                ]
            };
            
            // Create SVG for Sankey diagram
            const svg = d3.select("#sankey-container")
                .append("svg")
                .attr("width", sankeyWidth)
                .attr("height", sankeyHeight);
            
            // Set up the Sankey generator
            const sankey = d3.sankey()
                .nodeWidth(15)
                .nodePadding(10)
                .extent([[1, 1], [sankeyWidth - 1, sankeyHeight - 5]]);
            
            // Generate the Sankey layout
            const { nodes, links } = sankey(sankeyData);
            
            // Add links
            svg.append("g")
                .selectAll("path")
                .data(links)
                .enter()
                .append("path")
                .attr("d", d3.sankeyLinkHorizontal())
                .attr("stroke-width", d => Math.max(1, d.width))
                .attr("stroke", "#FFD700")
                .attr("fill", "none")
                .attr("opacity", 0.5)
                .on("mouseover", function(event, d) {
                    tooltip.transition().duration(200).style("opacity", 1);
                    tooltip.html(`${d.source.name} ‚Üí ${d.target.name}<br>Packages: ${Math.round(d.value).toLocaleString()}`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    tooltip.transition().duration(500).style("opacity", 0);
                });
            
            // Add nodes
            svg.append("g")
                .selectAll("rect")
                .data(nodes)
                .enter()
                .append("rect")
                .attr("x", d => d.x0)
                .attr("y", d => d.y0)
                .attr("height", d => d.y1 - d.y0)
                .attr("width", d => d.x1 - d.x0)
                .attr("fill", "#1E90FF")
                .attr("stroke", "#000")
                .on("mouseover", function(event, d) {
                    tooltip.transition().duration(200).style("opacity", 1);
                    tooltip.html(`${d.name}<br>Packages: ${Math.round(d.value).toLocaleString()}`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    tooltip.transition().duration(500).style("opacity", 0);
                });
            
            // Add node labels
            svg.append("g")
                .selectAll("text")
                .data(nodes)
                .enter()
                .append("text")
                .attr("x", d => d.x0 < sankeyWidth / 2 ? d.x1 + 6 : d.x0 - 6)
                .attr("y", d => (d.y1 + d.y0) / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", d => d.x0 < sankeyWidth / 2 ? "start" : "end")
                .text(d => d.name)
                .attr("font-size", "12px")
                .attr("fill", "#fff");
        }
        
        // Initialize County Map with filtering functionality
        function initializeCountyMap(data) {
            // Much of this code comes from heatmap_filtering.html
            const width = 960, height = 600;
            const svg = d3.select("#map");
            const gMap = svg.select("#gMap");

            // Create zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([1, 100])
                .on("zoom", (event) => {
                    gMap.attr("transform", event.transform);

                    const currentScale = event.transform.k;
                    const countyStrokeWidth = Math.max(0.3 / currentScale, 0.05);
                    const stateStrokeWidth = Math.max(2 / currentScale, 0.2);

                    d3.selectAll(".county").style("stroke-width", countyStrokeWidth + "px");
                    d3.selectAll(".state").style("stroke-width", stateStrokeWidth + "px");
                });

            svg.call(zoom);

            // Current filter state
            let currentFilter = null;

            // Load US county map data
            d3.json("https://cdn.jsdelivr.net/npm/us-atlas@3/counties-albers-10m.json").then(us => {
                const counties = topojson.feature(us, us.objects.counties);
                const states = topojson.mesh(us, us.objects.states);

                // Process data for map
                const processMapData = (data) => {
                    let countyCounts = d3.rollup(data, v => v.length, d => d["County FIPS"]);
                    return countyCounts;
                };

                // Process data for carrier chart
                const processCarrierData = (data) => {
                    let carrierCounts = d3.rollup(data, v => v.length, d => d["Carrier"] || "Unknown");
                    
                    // Convert to array for chart
                    let carrierData = Array.from(carrierCounts, ([key, value]) => ({
                        carrier: key === "Unknown" ? "Other" : key,
                        count: value
                    }));
                    
                    // Sort by count (descending)
                    carrierData.sort((a, b) => b.count - a.count);
                    
                    return carrierData;
                };

                // Store the full dataset
                const fullData = data;
                let filteredMapData = fullData;
                
                // Create maps to store county information
                const countyInfo = new Map();
                data.forEach(d => {
                    countyInfo.set(d["County FIPS"], {
                        county: d["Origin County"],
                        state: d["Origin State"]
                    });
                });

                // Initialize map with all data
                let countyCounts = processMapData(filteredMapData);
                const maxCount = d3.max([...countyCounts.values()]) || 1;

                // Create color scale for map
                const colorScale = d3.scaleLog()
                    .domain([1, maxCount])
                    .range(["#ffe6e6", "#ff0000"])
                    .clamp(true);
                
                const getColor = (count) => count > 0 ? colorScale(count) : "#222";
                const path = d3.geoPath();

                // Create county features
                const countyFeatures = gMap.append("g")
                    .selectAll("path")
                    .data(counties.features)
                    .enter().append("path")
                    .attr("class", "county")
                    .attr("d", path)
                    .attr("fill", d => getColor(countyCounts.get(d.id) || 0))
                    .on("mouseover", function(event, d) {
                        const currentScale = d3.zoomTransform(svg.node()).k; 
                        const hoverStrokeWidth = Math.max(1 / currentScale, 0.2); 

                        const countyFIPS = d.id;
                        const count = countyCounts.get(countyFIPS) || 0;
                        const info = countyInfo.get(countyFIPS) || { county: "Unknown", state: "Unknown" };

                        if (count === 0) return;

                        tooltip.transition().duration(200).style("opacity", 1);
                        tooltip.html(`<strong>${info.county} County, ${info.state}</strong><br>Packages: ${count}`)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");

                        d3.select(this)
                            .style("stroke", "#FFD700")
                            .style("stroke-width", hoverStrokeWidth + "px")
                            .raise();
                    })
                    .on("mouseout", function() {
                        const currentScale = d3.zoomTransform(svg.node()).k; 
                        const normalStrokeWidth = Math.max(0.3 / currentScale, 0.05); 

                        tooltip.transition().duration(500).style("opacity", 0);

                        d3.select(this)
                            .style("stroke", "#bbb") 
                            .style("stroke-width", normalStrokeWidth + "px");
                    });

                // Create state boundaries
                gMap.append("path")
                    .datum(states)
                    .attr("class", "state")
                    .attr("d", path)
                    .attr("fill", "none");

                // Create map legend
                createMapLegend(maxCount, colorScale);
                
                // Create carrier chart
                const carrierData = processCarrierData(fullData);
                createMapCarrierChart(carrierData);
                
                // Function to create map legend
                function createMapLegend(maxCount, colorScale) {
                    const legendSvg = d3.select("#legend");
                    const legendWidth = 300, legendHeight = 20;
                    
                    legendSvg.selectAll("*").remove(); // Clear previous legend
                    
                    const logScale = d3.scaleLog()
                        .domain([1, maxCount])
                        .range([0, legendWidth]);

                    const defs = legendSvg.append("defs");
                    const gradient = defs.append("linearGradient")
                        .attr("id", "legend-gradient")
                        .attr("x1", "0%").attr("x2", "100%")
                        .attr("y1", "0%").attr("y2", "0%");

                    const numStops = 10;
                    for (let i = 0; i <= numStops; i++) {
                        const t = i / numStops;
                        const logValue = Math.pow(maxCount, t);
                        gradient.append("stop")
                            .attr("offset", `${t * 100}%`)
                            .attr("stop-color", colorScale(logValue));
                    }
                    
                    const legend = legendSvg.append("g")
                        .attr("transform", `translate(${(500 - legendWidth) / 2}, 20)`);

                    legend.append("rect")
                        .attr("width", legendWidth)
                        .attr("height", legendHeight)
                        .style("fill", "url(#legend-gradient)")
                        .style("stroke", "#ccc")
                        .style("stroke-width", "1px");

                    legendSvg.append("text")
                        .attr("x", 500 / 2)
                        .attr("y", 15)
                        .style("text-anchor", "middle")
                        .style("font-weight", "bold")
                        .style("fill", "#fff")
                        .text(currentFilter ? `Packages from County (${currentFilter} Only)` : "Packages from County (Log Scale)");

                    const tickValues = [];
                    let baseTick = 1;
                    while (baseTick <= maxCount) {
                        tickValues.push(baseTick);
                        baseTick *= 10;
                    }

                    if (maxCount < 10) tickValues.splice(1, 0, 2, 5);

                    tickValues.forEach(value => {
                        if (value <= maxCount && value > 1) {
                            const xPos = logScale(value);
                            legend.append("line")
                                .attr("x1", xPos).attr("x2", xPos)
                                .attr("y1", legendHeight).attr("y2", legendHeight + 5)
                                .style("stroke", "#fff").style("stroke-width", "1px");

                            legend.append("text")
                                .attr("x", xPos)
                                .attr("y", legendHeight + 15)
                                .style("text-anchor", "middle")
                                .style("fill", "#fff")
                                .text(value);
                        }
                    });

                    // Add min and max labels
                    legend.append("text")
                        .attr("x", 0)
                        .attr("y", legendHeight + 15)
                        .style("text-anchor", "middle")
                        .style("fill", "#fff")
                        .text("1");
                    
                    legend.append("line")
                        .attr("x1", 0)
                        .attr("x2", 0)
                        .attr("y1", legendHeight)
                        .attr("y2", legendHeight + 5)
                        .style("stroke", "#fff")
                        .style("stroke-width", "1px");
                    
                    legend.append("text")
                        .attr("x", legendWidth)
                        .attr("y", legendHeight + 15)
                        .style("text-anchor", "middle")
                        .style("fill", "#fff")
                        .text(maxCount);

                    legend.append("line")
                        .attr("x1", legendWidth)
                        .attr("x2", legendWidth)
                        .attr("y1", legendHeight)
                        .attr("y2", legendHeight + 5)
                        .style("stroke", "#fff")
                        .style("stroke-width", "1px");
                }
                
                // Function to create carrier chart for map filtering
                function createMapCarrierChart(data) {
                    const barSvg = d3.select("#barChart");
                    const margin = { top: 30, right: 20, bottom: 50, left: 60 };
                    const barWidth = 800 - margin.left - margin.right;
                    const barHeight = 200 - margin.top - margin.bottom;
                    
                    // Clear previous chart
                    barSvg.selectAll("*").remove();
                    
                    const g = barSvg.append("g")
                        .attr("transform", `translate(${margin.left},${margin.top})`);
                    
                    // Set up scales
                    const x = d3.scaleBand()
                        .domain(data.map(d => d.carrier))
                        .range([0, barWidth])
                        .padding(0.3);
                    
                    const maxBarValue = d3.max(data, d => d.count);
                    
                    const y = d3.scaleLinear()
                        .domain([0, maxBarValue])
                        .nice()
                        .range([barHeight, 0]);
                    
                    // Add x axis
                    g.append("g")
                        .attr("transform", `translate(0,${barHeight})`)
                        .call(d3.axisBottom(x))
                        .selectAll("text")
                        .attr("y", 10)
                        .attr("x", -5)
                        .attr("text-anchor", "end")
                        .attr("transform", "rotate(-45)")
                        .style("fill", "#fff");
                    
                    // Add y axis
                    g.append("g")
                        .call(d3.axisLeft(y).ticks(5))
                        .selectAll("text")
                        .style("fill", "#fff");
                    
                    // Add y axis label
                    g.append("text")
                        .attr("transform", "rotate(-90)")
                        .attr("y", -40)
                        .attr("x", -barHeight / 2)
                        .attr("text-anchor", "middle")
                        .text("Number of Packages")
                        .style("fill", "#fff");
                    
                    // Add bars
                    g.selectAll(".bar")
                        .data(data)
                        .enter().append("rect")
                        .attr("class", "bar")
                        .attr("x", d => x(d.carrier))
                        .attr("y", d => y(d.count))
                        .attr("width", x.bandwidth())
                        .attr("height", d => barHeight - y(d.count))
                        .attr("fill", d => carrierColors[d.carrier] || "#2E8B57")
                        .attr("stroke", "#333")
                        .attr("stroke-width", d => d.carrier === currentFilter ? "2px" : "1px")
                        .attr("opacity", d => currentFilter && d.carrier !== currentFilter ? 0.5 : 1)
                        .style("cursor", "pointer")
                        .on("mouseover", function(event, d) {
                            if (currentFilter && d.carrier !== currentFilter) return;
                            
                            d3.select(this).attr("fill", d3.color(carrierColors[d.carrier] || "#2E8B57").brighter(0.5));
                            
                            barTooltip.transition().duration(200).style("opacity", 1);
                            barTooltip.html(`<strong>${d.carrier}</strong><br>${d.count.toLocaleString()} packages`)
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 28) + "px");
                        })
                        .on("mouseout", function(event, d) {
                            d3.select(this).attr("fill", carrierColors[d.carrier] || "#2E8B57");
                            barTooltip.transition().duration(500).style("opacity", 0);
                        })
                        .on("click", function(event, d) {
                            filterMapByCarrier(d.carrier);
                        });
                }
                
                // Function to filter map by carrier
                function filterMapByCarrier(carrier) {
                    // Update filter state
                    if (currentFilter === carrier) {
                        // If clicking the same carrier again, reset filter
                        currentFilter = null;
                        filteredMapData = fullData;
                        d3.select(".subtitle").text("Click on a carrier to filter the map");
                    } else {
                        // Set new filter
                        currentFilter = carrier;
                        filteredMapData = fullData.filter(d => 
                            carrier === "Other" 
                                ? !d["Carrier"] || d["Carrier"] === "Unknown" || !carrierColors[d["Carrier"]]
                                : d["Carrier"] === carrier
                        );
                        d3.select(".subtitle").text(`Showing packages from ${currentFilter} carrier - Click on ${currentFilter} again to reset`);
                    }
                    
                    // Update map with filtered data
                    updateMap();
                    
                    // Update bar chart highlighting
                    d3.selectAll(".bar")
                        .attr("opacity", d => currentFilter && d.carrier !== currentFilter ? 0.5 : 1)
                        .attr("stroke-width", d => d.carrier === currentFilter ? "2px" : "1px");
                }
                
                // Function to update map with filtered data
                function updateMap() {
                    // Recalculate county counts
                    countyCounts = processMapData(filteredMapData);
                    const newMaxCount = d3.max([...countyCounts.values()]) || maxCount;
                    
                    // Update color scale with new max count
                    const newColorScale = d3.scaleLog()
                        .domain([1, newMaxCount])
                        .range(["#ffe6e6", "#ff0000"])
                        .clamp(true);
                    
                    // Update county colors
                    countyFeatures.transition().duration(500)
                        .attr("fill", d => {
                            const count = countyCounts.get(d.id) || 0;
                            return count > 0 ? newColorScale(count) : "#222";
                        });
                    
                    // Clear and recreate legend
                    d3.select("#legend").selectAll("*").remove();
                    createMapLegend(newMaxCount, newColorScale);
                }
            });
        }
        
        // Create carrier bar chart for stats tab
        function createCarrierBar(data) {
            // Calculate carrier counts
            const carrierCounts = d3.rollup(data, v => v.length, d => d["Carrier"] || "Unknown");
            
            // Convert to array and sort
            const chartData = Array.from(carrierCounts, ([key, value]) => ({
                carrier: key === "Unknown" ? "Other" : key,
                count: value
            })).sort((a, b) => b.count - a.count);
            
            // Set up dimensions
            const width = 600;
            const height = 400;
            const margin = { top: 30, right: 30, bottom: 70, left: 60 };
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;
            
            // Create SVG
            const svg = d3.select("#carrier-bar-container")
                .append("svg")
                .attr("width", width)
                .attr("height", height);
                
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // Set up scales
            const x = d3.scaleBand()
                .domain(chartData.map(d => d.carrier))
                .range([0, innerWidth])
                .padding(0.3);
                
            const y = d3.scaleLinear()
                .domain([0, d3.max(chartData, d => d.count)])
                .nice()
                .range([innerHeight, 0]);
            
            // Add axes
            g.append("g")
                .attr("transform", `translate(0,${innerHeight})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .attr("transform", "rotate(-45)")
                .attr("text-anchor", "end")
                .attr("dx", "-.8em")
                .attr("dy", ".15em")
                .style("fill", "#fff");
                
            g.append("g")
                .call(d3.axisLeft(y))
                .selectAll("text")
                .style("fill", "#fff");
            
            // Add bars
            g.selectAll(".bar")
                .data(chartData)
                .enter()
                .append("rect")
                .attr("class", "bar")
                .attr("x", d => x(d.carrier))
                .attr("y", d => y(d.count))
                .attr("width", x.bandwidth())
                .attr("height", d => innerHeight - y(d.count))
                .attr("fill", d => carrierColors[d.carrier] || "#2E8B57")
                .on("mouseover", function(event, d) {
                    d3.select(this).attr("fill", d3.color(carrierColors[d.carrier] || "#2E8B57").brighter(0.5));
                    
                    tooltip.transition().duration(200).style("opacity", 1);
                    tooltip.html(`<strong>${d.carrier}</strong><br>${d.count.toLocaleString()} packages (${(d.count / data.length * 100).toFixed(1)}%)`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function(event, d) {
                    d3.select(this).attr("fill", carrierColors[d.carrier] || "#2E8B57");
                    tooltip.transition().duration(500).style("opacity", 0);
                });
            
            // Add title
            g.append("text")
                .attr("x", innerWidth / 2)
                .attr("y", -margin.top / 2)
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .style("fill", "#fff")
                .text("Package Distribution by Carrier");
        }
        
        // Create processing time histogram
        function createProcessingHistogram(data) {
            // Filter data for valid processing times
            const validData = data.filter(d => d["Total Processing Time"] !== undefined && 
                                             !isNaN(d["Total Processing Time"]) && 
                                             d["Total Processing Time"] > 0 &&
                                             d["Total Processing Time"] < 200); // Filter outliers
            
            // Set up dimensions
            const width = 600;
            const height = 400;
            const margin = { top: 30, right: 30, bottom: 50, left: 60 };
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;
            
            // Create SVG
            const svg = d3.select("#histogram-container")
                .append("svg")
                .attr("width", width)
                .attr("height", height);
                
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // Create histogram bins
            const histogram = d3.histogram()
                .value(d => d["Total Processing Time"])
                .domain([0, 100])
                .thresholds(20);
                
            const bins = histogram(validData);
            
            // Set up scales
            const x = d3.scaleLinear()
                .domain([0, 100])
                .range([0, innerWidth]);
                
            const y = d3.scaleLinear()
                .domain([0, d3.max(bins, d => d.length)])
                .nice()
                .range([innerHeight, 0]);
            
            // Add axes
            g.append("g")
                .attr("transform", `translate(0,${innerHeight})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .style("fill", "#fff");
                
            g.append("g")
                .call(d3.axisLeft(y))
                .selectAll("text")
                .style("fill", "#fff");
            
            // Add bars
            g.selectAll("rect")
                .data(bins)
                .enter()
                .append("rect")
                .attr("x", d => x(d.x0))
                .attr("y", d => y(d.length))
                .attr("width", d => Math.max(0, x(d.x1) - x(d.x0) - 1))
                .attr("height", d => innerHeight - y(d.length))
                .attr("fill", "#1E90FF")
                .on("mouseover", function(event, d) {
                    d3.select(this).attr("fill", d3.color("#1E90FF").brighter(0.5));
                    
                    tooltip.transition().duration(200).style("opacity", 1);
                    tooltip.html(`<strong>${d.x0.toFixed(1)} - ${d.x1.toFixed(1)} hours</strong><br>${d.length.toLocaleString()} packages`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    d3.select(this).attr("fill", "#1E90FF");
                    tooltip.transition().duration(500).style("opacity", 0);
                });
            
            // Add title and labels
            g.append("text")
                .attr("x", innerWidth / 2)
                .attr("y", -margin.top / 2)
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .style("fill", "#fff")
                .text("Distribution of Package Processing Times");
                
            g.append("text")
                .attr("x", innerWidth / 2)
                .attr("y", innerHeight + 40)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "#fff")
                .text("Processing Time (Hours)");
                
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -margin.left + 15)
                .attr("x", -innerHeight / 2)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "#fff")
                .text("Number of Packages");
        }
        
        // Create time line chart
        function createTimeLineChart(data) {
            // Filter and sort data for time chart
            const validData = data.filter(d => d["Routed Date Time"] && d["Total Processing Time"]);
            
            // Group data by day
            const timeData = d3.rollup(validData, 
                v => ({
                    date: v[0]["Routed Date Time"],
                    avgTime: d3.mean(v, d => d["Total Processing Time"]),
                    count: v.length
                }), 
                d => d3.timeFormat("%Y-%m-%d")(d["Routed Date Time"])
            );
            
            // Convert to array and sort by date
            const chartData = Array.from(timeData, ([key, value]) => ({
                date: new Date(key),
                avgTime: value.avgTime,
                count: value.count
            })).sort((a, b) => a.date - b.date);
            
            // Set up dimensions
            const width = 600;
            const height = 400;
            const margin = { top: 30, right: 30, bottom: 50, left: 60 };
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;
            
            // Create SVG
            const svg = d3.select("#line-chart-container")
                .append("svg")
                .attr("width", width)
                .attr("height", height);
                
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // Set up scales
            const x = d3.scaleTime()
                .domain(d3.extent(chartData, d => d.date))
                .range([0, innerWidth]);
                
            const y = d3.scaleLinear()
                .domain([0, d3.max(chartData, d => d.avgTime) * 1.1])
                .nice()
                .range([innerHeight, 0]);
                
            // Create color scale for points based on package count
            const pointColor = d3.scaleLinear()
                .domain([d3.min(chartData, d => d.count), d3.max(chartData, d => d.count)])
                .range(["#00BFFF", "#FF4500"]);
            
            // Add axes
            g.append("g")
                .attr("transform", `translate(0,${innerHeight})`)
                .call(d3.axisBottom(x))
                .selectAll("text")
                .style("fill", "#fff");
                
            g.append("g")
                .call(d3.axisLeft(y))
                .selectAll("text")
                .style("fill", "#fff");
            
            // Add line
            const line = d3.line()
                .x(d => x(d.date))
                .y(d => y(d.avgTime))
                .curve(d3.curveMonotoneX);
                
            g.append("path")
                .datum(chartData)
                .attr("fill", "none")
                .attr("stroke", "#32CD32")
                .attr("stroke-width", 2)
                .attr("d", line);
            
            // Add points
            g.selectAll("circle")
                .data(chartData)
                .enter()
                .append("circle")
                .attr("cx", d => x(d.date))
                .attr("cy", d => y(d.avgTime))
                .attr("r", d => Math.sqrt(d.count) / 5 + 3) // Size based on count
                .attr("fill", d => pointColor(d.count))
                .attr("stroke", "#fff")
                .attr("stroke-width", 1)
                .on("mouseover", function(event, d) {
                    d3.select(this)
                        .attr("r", Math.sqrt(d.count) / 5 + 5)
                        .attr("stroke-width", 2);
                    
                    tooltip.transition().duration(200).style("opacity", 1);
                    tooltip.html(`<strong>${d3.timeFormat("%b %d, %Y")(d.date)}</strong><br>
                                Avg. Processing: ${d.avgTime.toFixed(2)} hours<br>
                                Packages: ${d.count.toLocaleString()}`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function(event, d) {
                    d3.select(this)
                        .attr("r", Math.sqrt(d.count) / 5 + 3)
                        .attr("stroke-width", 1);
                    tooltip.transition().duration(500).style("opacity", 0);
                });
            
            // Add title and labels
            g.append("text")
                .attr("x", innerWidth / 2)
                .attr("y", -margin.top / 2)
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .style("fill", "#fff")
                .text("Average Processing Time Over Time");
                
            g.append("text")
                .attr("x", innerWidth / 2)
                .attr("y", innerHeight + 40)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "#fff")
                .text("Date");
                
            g.append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -margin.left + 15)
                .attr("x", -innerHeight / 2)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "#fff")
                .text("Average Processing Time (Hours)");
        }
        
        // Create carrier pie chart
        function createCarrierPieChart(data) {
            // Calculate carrier counts
            const carrierCounts = d3.rollup(data, v => v.length, d => d["Carrier"] || "Unknown");
            
            // Convert to array and sort
            const chartData = Array.from(carrierCounts, ([key, value]) => ({
                carrier: key === "Unknown" ? "Other" : key,
                count: value
            })).sort((a, b) => b.count - a.count);
            
            // Set up dimensions
            const width = 500;
            const height = 400;
            const radius = Math.min(width, height) / 2;
            
            // Create SVG
            const svg = d3.select("#pie-chart-container")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", `translate(${width / 2},${height / 2})`);
            
            // Create color scale
            const color = d3.scaleOrdinal()
                .domain(chartData.map(d => d.carrier))
                .range(chartData.map(d => carrierColors[d.carrier] || "#2E8B57"));
            
            // Create pie generator
            const pie = d3.pie()
                .value(d => d.count)
                .sort(null);
                
            // Create arc generator
            const arc = d3.arc()
                .innerRadius(0)
                .outerRadius(radius * 0.8);
                
            // Create outer arc for labels
            const outerArc = d3.arc()
                .innerRadius(radius * 0.9)
                .outerRadius(radius * 0.9);
            
            // Add pie segments
            const segments = svg.selectAll("path")
                .data(pie(chartData))
                .enter()
                .append("path")
                .attr("d", arc)
                .attr("fill", d => color(d.data.carrier))
                .attr("stroke", "#222")
                .style("stroke-width", "2px")
                .on("mouseover", function(event, d) {
                    d3.select(this)
                        .attr("opacity", 0.8)
                        .attr("stroke", "#fff");
                    
                    tooltip.transition().duration(200).style("opacity", 1);
                    tooltip.html(`<strong>${d.data.carrier}</strong><br>
                                ${d.data.count.toLocaleString()} packages<br>
                                ${(d.data.count / data.length * 100).toFixed(1)}% of total`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    d3.select(this)
                        .attr("opacity", 1)
                        .attr("stroke", "#222");
                    tooltip.transition().duration(500).style("opacity", 0);
                });
            
            // Add labels
            const text = svg.selectAll("text")
                .data(pie(chartData))
                .enter();
                
            // Add label lines
            function midAngle(d) {
                return d.startAngle + (d.endAngle - d.startAngle) / 2;
            }
            
            // Only add lines and labels for segments with enough room
            text.filter(d => (d.endAngle - d.startAngle) > 0.2)
                .append("polyline")
                .attr("stroke", "#fff")
                .attr("fill", "none")
                .attr("points", function(d) {
                    const pos = outerArc.centroid(d);
                    pos[0] = radius * 0.95 * (midAngle(d) < Math.PI ? 1 : -1);
                    return [arc.centroid(d), outerArc.centroid(d), pos];
                });
                
            // Add carrier labels
            text.filter(d => (d.endAngle - d.startAngle) > 0.2)
                .append("text")
                .attr("transform", function(d) {
                    const pos = outerArc.centroid(d);
                    pos[0] = radius * (midAngle(d) < Math.PI ? 1 : -1);
                    return `translate(${pos})`;
                })
                .attr("dy", ".35em")
                .attr("text-anchor", d => midAngle(d) < Math.PI ? "start" : "end")
                .text(d => d.data.carrier)
                .style("fill", "#fff")
                .style("font-size", "12px");
            
            // Add title
            svg.append("text")
                .attr("x", 0)
                .attr("y", -height / 2 + 20)
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .style("fill", "#fff")
                .text("Package Volume by Carrier");
        }
        
        // Create pickup heatmap
        function createPickupHeatmap(data) {
            // Filter data for valid delivery dates
            const validData = data.filter(d => d["Delivered Date Time"]);
            
            // Create data for heatmap
            const heatmapData = validData.map(d => {
                const date = d["Delivered Date Time"];
                return {
                    hour: date.getHours(),
                    day: date.getDay(),
                    value: 1
                };
            });
            
            // Aggregate data by day and hour
            const aggregatedData = d3.rollup(heatmapData,
                v => v.length,
                d => d.day,
                d => d.hour
            );
            
            // Convert to array format for heatmap
            const chartData = [];
            for (const [day, hours] of aggregatedData.entries()) {
                for (const [hour, count] of hours.entries()) {
                    chartData.push({ day, hour, count });
                }
            }
            
            // Set up dimensions
            const width = 700;
            const height = 500;
            const margin = { top: 50, right: 30, bottom: 60, left: 80 };
            const innerWidth = width - margin.left - margin.right;
            const innerHeight = height - margin.top - margin.bottom;
            
            // Create SVG
            const svg = d3.select("#pickup-heatmap-container")
                .append("svg")
                .attr("width", width)
                .attr("height", height);
                
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);
            
            // Set up scales
            const x = d3.scaleBand()
                .domain(d3.range(0, 24))
                .range([0, innerWidth])
                .padding(0.05);
                
            const y = d3.scaleBand()
                .domain(d3.range(0, 7))
                .range([0, innerHeight])
                .padding(0.05);
                
            const color = d3.scaleSequential()
                .domain([0, d3.max(chartData, d => d.count)])
                .interpolator(d3.interpolateInferno);
            
            // Add days of week labels
            const daysOfWeek = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
            g.selectAll(".day-label")
                .data(daysOfWeek)
                .enter()
                .append("text")
                .attr("class", "day-label")
                .attr("x", -10)
                .attr("y", (d, i) => y(i) + y.bandwidth() / 2)
                .attr("text-anchor", "end")
                .attr("dominant-baseline", "middle")
                .style("fill", "#fff")
                .text(d => d);
            
            // Add hour labels
            g.selectAll(".hour-label")
                .data(d3.range(0, 24))
                .enter()
                .append("text")
                .attr("class", "hour-label")
                .attr("x", d => x(d) + x.bandwidth() / 2)
                .attr("y", innerHeight + 10)
                .attr("text-anchor", "middle")
                .style("fill", "#fff")
                .text(d => d);
            
            // Add title and labels
            g.append("text")
                .attr("x", innerWidth / 2)
                .attr("y", -margin.top / 2)
                .attr("text-anchor", "middle")
                .style("font-size", "16px")
                .style("fill", "#fff")
                .text("Package Pickup Heatmap by Day and Hour");
                
            g.append("text")
                .attr("x", innerWidth / 2)
                .attr("y", innerHeight + 40)
                .attr("text-anchor", "middle")
                .style("font-size", "14px")
                .style("fill", "#fff")
                .text("Hour of Day");
            
            // Add heatmap cells
            g.selectAll("rect")
                .data(chartData)
                .enter()
                .append("rect")
                .attr("x", d => x(d.hour))
                .attr("y", d => y(d.day))
                .attr("width", x.bandwidth())
                .attr("height", y.bandwidth())
                .attr("fill", d => color(d.count))
                .attr("stroke", "#222")
                .attr("stroke-width", 1)
                .on("mouseover", function(event, d) {
                    d3.select(this)
                        .attr("stroke", "#fff")
                        .attr("stroke-width", 2);
                    
                    tooltip.transition().duration(200).style("opacity", 1);
                    tooltip.html(`<strong>${daysOfWeek[d.day]}, ${d.hour}:00</strong><br>
                                ${d.count.toLocaleString()} packages`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function() {
                    d3.select(this)
                        .attr("stroke", "#222")
                        .attr("stroke-width", 1);
                    tooltip.transition().duration(500).style("opacity", 0);
                });
            
            // Add legend
            const legendWidth = 20;
            const legendHeight = innerHeight * 0.7;
            
            // Create gradient
            const defs = svg.append("defs");
            const linearGradient = defs.append("linearGradient")
                .attr("id", "heatmap-gradient")
                .attr("x1", "0%")
                .attr("y1", "100%")
                .attr("x2", "0%")
                .attr("y2", "0%");
                
            // Add color stops
            const colorScale = color.domain();
            const numStops = 10;
            for (let i = 0; i <= numStops; i++) {
                const offset = i / numStops;
                const value = colorScale[0] + offset * (colorScale[1] - colorScale[0]);
                linearGradient.append("stop")
                    .attr("offset", `${offset * 100}%`)
                    .attr("stop-color", color(value));
            }
            
            // Add legend rectangle
            const legend = svg.append("g")
                .attr("transform", `translate(${width - margin.right + 10}, ${margin.top + (innerHeight - legendHeight) / 2})`);
                
            legend.append("rect")
                .attr("width", legendWidth)
                .attr("height", legendHeight)
                .style("fill", "url(#heatmap-gradient)")
                .style("stroke", "#fff");
            
            // Add legend labels
            legend.append("text")
                .attr("x", legendWidth / 2)
                .attr("y", -10)
                .attr("text-anchor", "middle")
                .style("fill", "#fff")
                .text("Count");
                
            legend.append("text")
                .attr("x", legendWidth / 2)
                .attr("y", legendHeight + 10)
                .attr("text-anchor", "middle")
                .style("fill", "#fff")
                .text("0");
                
            legend.append("text")
                .attr("x", legendWidth / 2)
                .attr("y", 0)
                .attr("text-anchor", "middle")
                .style("fill", "#fff")
                .text(d3.max(chartData, d => d.count).toFixed(0));
        }
    </script>
</body>
</html>
